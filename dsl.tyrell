# First, specify the types that will be used
enum Const {
  "const"
}

value Table {
  col: int;
  row: int;
  groups: int;
}

value Empty;

# Next, specify the input/output of the synthesized program
program Morpheus(Table) -> Table;

# Finally, specify the production rules
func empty: Empty -> Empty;


func summarise: Table r -> Table a, Const b, Const c {
  row(r) <= row(a);
  col(r) <= col(a) + 1;
  groups(r) <= groups(a);
}

func group_by: Table r -> Table a, Const b {
  row(r) == row(a);
  col(r) == col(a);
  groups(r) < groups(a);
}

func count: Table r -> Table a {
  row(r) <= row(a);
  col(r) <= col(a) + 1;
  groups(r) <= groups(a);
}

func top_n: Table r -> Table a, Const b, Const c {
  row(r) <= row(a);
}

func bottom_n: Table r -> Table a, Const b, Const c {
  row(r) <= row(a);
}

func mutate: Table r -> Table a, Const b, Const c, Const d {
  row(r) == row(a);
  col(r) == col(a);
  groups(r) == groups(a);
}

func filter: Table r -> Table a, Const b, Const c {
  row(r) <= row(a) - 1;
  col(r) == col(a);
}


predicate occurs(group_by, 1);
predicate occurs(summarise, 2);
predicate occurs(count, 3);


#Hard constraints


predicate sequence(summarise, group_by); # summarize => group_by
predicate sequence(count, group_by); # count => group_by
                                     # group_by => summarize or count

predicate order_restriction(top_n, count); # top_n => count or summarize or mutate
predicate order_restriction(top_n, summarise); # top_n => count or summarize or mutate
predicate order_restriction(top_n, mutate); # top_n => count or summarize or mutate

predicate order_restriction(bottom_n, count); # bottom_n => count or summarize or mutate
predicate order_restriction(bottom_n, summarise); # bottom_n => count or summarize or mutate
predicate order_restriction(bottom_n, mutate); # bottom_n => count or summarize or mutate

predicate only_at_root(top_n);
predicate only_at_root(bottom_n);
